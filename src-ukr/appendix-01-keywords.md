## Додаток A: ключові слова

Цей список містить ключові слова, зарезервовані для поточного або майбутнього використання в мові Rust. Відтак, вони не можуть використовуватися як ідентифікатори (крім сирих ідентифікаторів, як обговорюється в розділі "[Сирі ідентифікатори][raw-identifiers]<!-- ignore -->). Ідентифікатори - це імена функцій, змінних, параметрів, полів структур, модулів, крейтів, констант, макросів, статичних значень, атрибутів, типів, трейтів і часів існування.

### Ключові слова, що використовуються

Далі наведено список ключових слів, що використовують зараз, з описом їхнього призначення.

* `as` - виконати примітивне перетворення, прибрати неоднозначність трейта, що містить елемент, чи перейменувати елементи інструкції `use`
* `async` -  повернути `Future` замість блокувати поточний потік
* `await` - припинити виконання, доки результат `Future` не буде готовим
* `break` - негайно вийти з циклу
* `const` - визначити константу чи константний вказівник
* `continue` - продовжити цикл з наступної ітерації
* `crate` - у шляху модуля посилається на корінь крейта
* `dyn` - динамічна диспетчеризація трейтового об'єкта
* `else` - альтернативний рукав для конструкцій керування `if` та `if let`
* `enum` - визначення енума
* `extern` - зв'язати зовнішню функцію або змінну
* `false` - булевий літерал "хиба"
* `fn` - визначити функцію чи тип вказівника на функцію
* `for` - цикл по елементах ітератора, реалізувати трейт, чи зазначити більш значущий час існування
* `if` - виконати код залежно від умовного виразу
* `impl` - реалізувати притаманну функціональність чи трейт
* `in` - частина синтаксису циклу `for`
* `let` - зв'язати змінну
* `loop` - безумовний цикл
* `match` - зіставити значення з шаблонами
* `mod` - визначити модуль
* `move` - передати замиканню володіння усіма захопленими значеннями
* `mut` - позначити мутабельність у посиланнях, вказівниках чи шаблонних зв'язуваннях
* `pub` - позначити публічну видимість у полях структур, блоках `impl` та модулях
* `ref` - зв'язати за посиланням
* `return` - повернення з функції
* `Self` - псевдонім типу для типу, який ми визначаємо чи реалізуємо
* `self` - суб'єкт методу чи поточний модуль
* `static` - глобальна змінна чи час існування, що триває весь час виконання програми
* `struct` - визначити структуру
* `super` - батьківський модуль відносно поточного
* `trait` - визначити трейт
* `true` - булевий літерал "правда"
* `type` - визначити псевдонім типу чи асоційований тип
* `union` - визначити [об'єднання][union]<!-- ignore -->; є ключовим словом виключно при проголошенні об'єднання
* `unsafe` - позначає небезпечний код, функції, трейти чи реалізації
* `use` - ввести символи у область видимості
* `where` - позначає обмеження типу
* `while` - умовний цикл залежно від значення виразу

### Ключові слова, зарезервовані для використання в майбутньому

Наступні ключові слова ще не мають функціональності, та є зарезервованими в Rust для можливого використання у майбутньому.

* `abstract`
* `become`
* `box`
* `do`
* `final`
* `macro`
* `override`
* `priv`
* `try`
* `typeof`
* `unsized`
* `virtual`
* `yield`

### Сирі ідентифікатори

*Сирі ідентифікатори* - це синтаксис, що дозволяє використовувати ключові слова там, де зазвичай це заборонено. Для використання сирого ідентифікатора, додайте до ключового слова префікс `r#`.

Наприклад `match` є ключовим словом. Якщо ви спробуєте скомпілювати цю функцію, що використовує `match` як ім'я:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

то отримаєте таку помилку:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

Ця помилка показує, що не можна використати ключове слово `match` як ідентифікатор функції. Щоб використати `match` як назву функції, вам доведеться використати синтаксис сирого ідентифікатора, ось так:

<span class="filename">Файл: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

Цей код компілюється без помилок. Зверніть увагу, що префікс `r#` в імені функції є як у визначенні, так і там, де ми викликаємо цю функцію в `main`.

Сирі ідентифікатори дозволяють вам використовувати будь-яке слово як ідентифікатор, навіть якщо воно зарезервоване як ключове слово. Це надає нам більше свободи для вибору назв ідентифікаторів, а також дозволяє інтегруватися з програмами, написаними мовами, де ці слова не є ключовими. На додачу, сирі ідентифікатори дозволяють вам використовувати бібліотеки, написані в редакціях Rust, що відрізняються від вашого крейта. Наприклад,, `try` не було ключовим словом у редакції 2015, але стало у редакції 2018. Якщо ви залежите від бібліотеки, що написана в редакції 2015 і має функцію `try`, вам знадобиться синтаксис сирого ідентифікатора, в цьому випадку `r#try`, щоб викликати цю функцію з коду в редакції 2018. Див. [Додаток E][appendix-e]<!-- ignore --> щоб отримати більше інформації про редакції.

[raw-identifiers]: #raw-identifiers

[union]: ../reference/items/unions.html

[appendix-e]: appendix-05-editions.html
