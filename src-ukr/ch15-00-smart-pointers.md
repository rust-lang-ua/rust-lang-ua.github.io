# Розумні вказівники

*Вказівник* - загальна концепція для змінної що містить адрес в памяті. Цей адрес посилаєтся, або "вказує", на певну інформацію. Найбільш розповсюджений вид вказівника в Расті це посилання, яке ви вивчили в Розділі 4. Посилання позначені символом `&` та позичають значення на яке вказують. Вони не мають інших можливостей ніж посилання на інформацію та не мають накладних витрат.

*Розумні вказівники*, з іншої сторони, є структурами даних що поводять себе як вказівник, але також мають додаткову метадату та можливості. Концепція розумних вказівників не унікальна для Расту: розумні вказівники виникли в C++ та також є в інших мовах програмування. Раст має різні розумні вказівники, визначені стандартною бібліотекою, які надають додатковий функціонал, крім того що наданий посиланнями. Для роз'яснення основної концепції ми подивимось на різні приклади розумних вказівників, включаючи *підраховуючий вказівники* тип розумних вказівників. Цей вказівник дозволяє мати декілька володарів завдяки відстежуванню кількості володарів. Коли володарів не залишится - інформація буде видалена.

Оскільки Раст має власну концепцію володіння та позичання є додаткова різниця між посиланнями та розумними вказіввниками: посилання лише позичають значення, але в багатьох випадках розумні вказівники  *володіють* значенням, на який вказують.

Хоча ми не так част овизивали їх на даний момент, ми вже зустрілись з деякими розумниви вказівниками в цій книзі, включно `String` та `Vec<T>` в Розділі 8. Обидва типи вважаются розумниви вказівниками оскільки вони володіють деякою памяттю і дозволяють програмісту маніпулювати нею. Вони також мають метадату та додаткові можливості чи гарантії. `String`, наприклад, зберігає свою ємкість як мета дату та має додаткове забезпечення, що вся інформація буде дійсною в UTF-8.

Розумні покажчики зазвичай реалізуються за допомогою структур. На відміну від звичайних структур, розумні вказівники реалізують `Deref` та `Drop` трейти. Трейт `Deref` дозволяэ экземпляру структури розумного вказівника поводитись як посилання ви можете писати свій код для роботи і з посиланнями, і з розумними вказівниками. Трейт `Drop` дозволяє змінити процеси що відбудуться при виході експемляру розумного вказівника з області видимості. В цьому розділі буде розглянуто обидва крейти та продемонстровано чому вони важливі для розумних вказівників.

Даний зразок розумного вказівника - загальний зразок проектування, часто використовуваний в Расті. Цей розділ не оглядає кожен існуючий розумний вказівник. Багато бібліотек мають свої власні розумні вказівники, а ви також можете написати свій. Ми розглянемо базові розумні вказівники стандартної бібліотеки

* `Box<T>` для розміщення значень в heap
* `Rc<T>`, тип з підрахунком посилань, який уможливлює множинне володіння
* `Ref<T>` та `RefMut<T>`, accessed through `RefCell<T>`, тип що забезпечує виконання правил запозичення під час виконання, а не компіляції

Додатково ми розглянемо зразок *внутрішньої змінюваності* де незмінний тип надає API для зміни внутрішнього значення. Також будуть розглянуті *зациклювання посиланнь*: як вони можуть розтратити пам'ять та як цьому запобігти.

Отже, вперед!
