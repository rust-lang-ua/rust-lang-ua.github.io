## Приймання аргументів командного рядка

Створімо новий проєкт за допомогою, як завжди, `cargo new`. Ми назвемо наш проєкт `minigrep`, щоб вирізнити його від інструменту `grep`, що вже може бути встановлено у вашій системі.

```console
$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```

Перше завдання - зробити, щоб `minigrep` приймав два аргументи командного рядка: шлях до файлу і стрічку для пошуку. Тобто ми хочемо, щоб нашу програму можна було запускати за допомогою `cargo run`, двох рисок на позначення що подальші аргументи стосуються нашої програми, а не `cargo`, стрічки для пошуку і шляху до файлу, в якому треба шукати, ось так:

```console
$ cargo run -- searchstring example-filename.txt
```

Наразі програма, створена `cargo new`, не може обробляти аргументи, передані їй. Певні бібліотеки з [crates.io](https://crates.io/) можуть допомогти писати програму, що приймає аргументи командного рядка, але оскільки ви лише вивчаєте цю концепцію, запровадимо цю можливість самостійно.

### Читання значень параметрів

Щоб дозволити `minigrep` читати значення аргументів командного рядка, переданих йому, нам знадобиться функція `std::env::args` зі стандартної бібліотеки Rust. Ця функція поверне ітератор аргументів командного рядка, переданих `minigrep`. Повніше про ітератори піде у [Розділі 13][ch13]<!-- ignore
-->. Поки що вам лише треба знати про ітератори дві речі: ітератори створюють послідовність значень, і ми можемо викликати метод 

`collect` для ітератора, щоб перетворити його на колекцію, таку як вектор, що міститиме всі елементи, створені ітератором.

`collect` method on an iterator to turn it into a collection, such as a vector, that contains all the elements the iterator produces.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-01/src/main.rs}}
```


<span class="caption">Listing 12-1: Collecting the command line arguments into a vector and printing them</span>

Спершу ми вводимо модуль `std::env` до області видимості за допомогою інструкції `use`, щоб можна було скористатися функцію `args` з цього модуля. Зверніть увагу, що функція `std::env::args` вкладена у два рівні модулів. Як ми вже говорили у [Розділі 7][ch7-idiomatic-use]<!-- ignore -->, у випадках, коли потрібна функція, вкладена глибше одного модуля, краще ввести в область видимості її батьківський модуль, аніж саму функцію. Таким чином, ми зможемо легко використовувати інші функції з `std::env`. Також це дещо менш двозначне, ніж додавання `use std::env::args` і виклик функції як просто `args`, бо просто `args` можна легко переплутати з функцією, визначеною в поточному модулі.

> ### Функція `args` і некоректний юнікод
> 
> Зверніть увагу, що `std::env::args` запанікує, якщо якийсь із аргументів містить некоректний юнікод. Якщо вашій програмі треба приймати аргументи з некоректним юнікодом, скористайтеся натомість функцією `std::env::args_os`. Вона повертає ітератор, що створює значення `OsString` замість `String`. Ми вирішили скористатися `std::env::args` для простоти, бо значення `OsString` різняться між платформами і з ними складніше працювати, ніж зі `String`.

У першому рядку `main` ми викликаємо `env::args` і одразу ж використовуємо `collect`, щоб перетворити ітератор на вектор, що містить усі значення, вироблені ітератором. Ми можемо використати функцію `collect`, щоб створити багато видів колекцій, тому явно позначаємо тип `args`, щоб вказати, що нам потрібен вектор стрічок. Хоча в Rust дуже нечасто треба позначати типи, `collect` є однією з функцій, яка часто потребує анотацій, бо Rust неспроможний вивести потрібний тип колекції.

В кінці ми виводимо вектор за допомогою макросу для зневаджування. Спробуймо тепер запустити код спершу без аргументів, а тоді з двома аргументами:

```console
{{#include ../listings/ch12-an-io-project/listing-12-01/output.txt}}
```

```console
{{#include ../listings/ch12-an-io-project/output-only-01-with-args/output.txt}}
```

Зверніть увагу, що перше значення у векторі - `"target/debug/minigrep"`, тобто назва нашого двійкового файлу. Це відповідає поведінці списку параметрів у C, що дозволяє програмам використовувати ім'я, за яким їх викликано, під час виконання. Часто буває зручно мати доступ до імені програми, якщо ви хочете вивести його у повідомленнях чи змінити поведінку програми залежно від того, який псевдонім був використаний у командному рядку для запуску програми. Але задля потреб нашого розділу ми пропустимо його і збережемо лише два потрібні параметри.

### Збереження значень параметрів у змінних

Програма вже може отримати значення, задані аргументами командного рядка. Тепер нам треба зберегти значення двох аргументів у змінних, щоб можна було використати ці значення далі в програмі. Це ми робимо у Блоці коду 12-2.

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-02/src/main.rs}}
```


<span class="caption">Listing 12-2: Creating variables to hold the query argument and file path argument</span>

Як ми бачили, коли виводили вектор, ім'я програми займає перше значення у векторі за індексом `args[0]`, тому ми починаємо аргументи з індексу `1`. Перший аргумент, що приймає `minigrep` - це шукана стрічка, тож ми розміщуємо посилання на перший аргумент у змінній `query`. Другий аргумент буде шляхом до файлу, тож ми розміщуємо посилання на другий аргумент у змінній `file_path`.

Ми тимчасово виводимо значення цих змінних, щоб підтвердити, що код працює, як ми очікували. Запустімо цю програму знову з аргументами `test` і `sample.txt`:

```console
{{#include ../listings/ch12-an-io-project/listing-12-02/output.txt}}
```

Чудово, програма працює! Значення потрібних нам аргументів зберігаються у правильних змінних. Пізніше ми додамо трохи обробки помилок, щоб розібратися з певними потенційними помилковими ситуаціями, на кшталт коли користувач не надає жодних параметрів; а поки що ігноруватимемо цю ситуацію і натомість займемося додаванням можливостей для читання файлів.

[ch13]: ch13-00-functional-features.html
[ch7-idiomatic-use]: ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths
