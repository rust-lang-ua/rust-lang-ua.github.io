## Покращуємо наш проєкт з введенням/виведенням

Використовуючи нові знання про ітератори, ми можемо покращити проєкт введення/виведення у Розділі 12, використовуючи ітератори, щоб зробити деякі місця в коді яснішими та виразнішими. Погляньмо, як ітератори можуть поліпшити нашу реалізацію функцій `Config::build` і `search`.

### Видалення `clone` за допомогою ітератора

У Блоці коду 12-6 ми додали код, що бере слайс зі значень `String` і створили екземпляр структури `Config` індексуванням слайса і клонуванням значень, дозволивши структурі `Config` володіти цими значеннями. У Блоці коду 13-17 ми відтворили реалізацію функції `Config::build` такою, як у Блоці коду 12-23:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-23-reproduced/src/lib.rs:ch13}}
```


<span class="caption">Блок коду 13-17: відтворення функції `Config::build` з Блоку коду 12-23</span>

Тоді ми казали не хвилюватися через неефективні виклики `clone`, оскільки ми видалимо їх e майбутньому. Що ж, цей час настав!

Нам тут потрібен `clone`, тому що ми маємо слайс з елементами `String` у параметрі `args`, але функція `build` не володіє `args`. Щоб повернути володіння екземпляром `Config`, нам довелося клонувати значення з полів `query` та `filename` з `Config`, щоб екземпляр `Config` міг володіти своїми значеннями.

За допомогою нових знань про ітератори см можемо змінити функцію `build`, щоб вона брала володіння ітератором як аргумент замість позичати слайс. Ми використаємо функціональність ітератора замість коду, що перевіряє довжину слайса і індексує конкретні місця. Це прояснить, що саме робить функція `Config::build`, бо доступ до значень забезпечуватиме ітератор.

Коли `Config::build` прийме володіння ітератором та припинить використовувати операції індексації, що позичають, ми зможемо перемістити значення `String` з ітератора в `Config` замість викликати `clone` і робити новий розподіл пам'яті.

#### Використання повернутого ітератора напряму

Відкрийте файл *src/main.rs* з нашого проєкту введення/виведення, що виглядає ось так:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-24-reproduced/src/main.rs:ch13}}
```

Ми спочатку змінимо початок функції `main`, яка була в нас у Блоці коду 12-24, на коду з Блоку коду 13-18, який на цей раз використовує ітератор. Це не буде компілюватися, доки ми не оновимо також `Config::build`.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-18/src/main.rs:here}}
```


<span class="caption">Блок коду 13-18: передавання значення, повернутого `env::args`, до `Config::build`</span>

Функція `env::args` повертає ітератор! Замість того, щоб збирати значення ітератора до вектора і передавання слайс до `Config::build`, тепер ми передаємо володіння ітератором, повернутим з `env::args`, напряму до `Config::build`.

Далі, нам потрібно оновити визначення `Config::build`. У файлі *src/lib.rs* вашого проєкту введення/виведення змінімо сигнатуру `Config::build`, щоб вона виглядала як у Блоці коду 13-19. Це все ще не компілюється, оскільки нам потрібно оновити тіло функції.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-19/src/lib.rs:here}}
```


<span class="caption">Блок коду 13-19: оновлення сигнатури `Config::build`, щоб приймала ітератор</span>

The standard library documentation for the `env::args` function shows that the type of the iterator it returns is `std::env::Args`, and that type implements the `Iterator` trait and returns `String` values.

Ми оновили сигнатуру функції `Config::build`, зробивши параметр `args` узагальненого типу з обмеженням трейту `impl Iterator<Item = String>` замість `&[String]`. Цей синтаксис `impl Trait`, який ми обговорили у підрозділі [“Трейти як параметри”][impl-trait]<!-- ignore --> Розділу 10, означає, що `args` може бути будь-якого типу, що реалізує тип `Iterator` і повертає елементи типу `String`.

Оскільки ми беремо володіння `args` і ми будемо змінювати `args`, ітеруючи крізь нього, ми можемо додати ключове слово `mut` в специфікацію параметра `args`, щоб зробити його мутабельним.

#### Використання методів трейту `Iterator` замість індексування

Далі ми виправимо тіло `Config::build`. Оскільки `args` реалізує трейт `Iterator`, ми знаємо, що можемо викликати для нього метод `next`! Блок коду 13-20 оновлює код зі Блоку коду 12-23, використовуючи метод `next`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-20/src/lib.rs:here}}
```


<span class="caption">Блок коду 13-20: зміна тіла `Config::build` з використанням методів ітератора</span>

Згадайте, що перша стрічка в значенні, яке повертає `env::args`, є назвою програми. Ми хочемо проігнорувати його і дістатися до наступного значення, тож спершу викличемо `next` і нічого не зробимо з поверненим значенням. По-друге, ми викликаємо `next`, щоб отримати значення, ми хочемо вставити в поле `Config` `query`. Якщо `next` повертає `Some`, ми використовуємо `match`, щоб витягти значення. Якщо вона повертає `None`, це означає, що було недостатньо аргументів, і ми достроково виходимо, повертаючи значення `Err`. Те саме ми робимо і зі значенням `filename`.

### Робимо код яснішим за допомогою адаптерів ітераторів

Ми також можемо скористатися ітераторами у функції `search` у нашому проєкті введення/виведення, який відтворений тут у Блоці коду 13-21 таким, як він був 12-19:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:ch13}}
```


<span class="caption">Блок коду 13-21: реалізація функції `search` з Блоку коду 12-19</span>

Ми можемо зробити цей код чіткішим за допомогою методів-адаптерів ітераторів. Це також дозволить нам уникнути проміжного мутабельного вектору `results`. Функціональний стиль програмування надає перевагу мінімізації кількості мутабельних станів, щоб зробити код чистішим. Видалення мутабельного стану може уможливити подальше покращення для здійснення паралельного пошуку, оскільки ми не змогли б керувати одночасним доступом до вектора `results`. Блок коду 13-22 показує ці зміни:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-22/src/lib.rs:here}}
```


<span class="caption">Блок коду 13-22: використання методів-адаптерів ітераторів у реалізації функції `search`</span>

Згадайте, що призначення функції `search` - повернути всі рядки в `contents`, що містять `query`. Так само як у прикладі `filter` з Блоку коду 13-16, цей код використовує адаптер `filter` для збереження тільки тих рядків, для яких `line.contains(query)` повертає `true`. Потім ми збираємо відповідні рядки у інший вектор за допомогою `collect`. Набагато простіше! Можете самі спробувати внести аналогічні зміни з використанням методів ітератора у функцію `search_case_insensitive`.

### Вибір між циклами або ітераторами

Наступне логічне питання - який стиль вам слід обрати у вашому власному коді й чому: оригінальна реалізація з Блоку коду 13-21 чи версія з ітераторами з Блоку коду 13-22. Більшість програмістів Rust вважають за краще використовувати ітераторний стиль. До нього дещо складніше призвичаїтися в перший час, але відколи ви набудете відчуття різноманітних ітераторів і що вони роблять, ітератори стають простішими для розуміння. Замість того, щоб займатися дрібними уточненнями в циклі й збирати нові вектори, код зосереджується на високорівневій меті циклу. Це дозволяє абстрагуватися від деякого банального коду, щоб легше було побачити концепції, унікальні для цього коду, такі як умови фільтрації, яку має пройти кожен елемент ітератора.

Але чи ці дві реалізації дійсно еквівалентні? Інтуїтивне припущення може казати, що більш низькорівневий цикл буде швидшим. Поговорімо про швидкодію.

[impl-trait]: ch10-02-traits.html#traits-as-parameters
