## Контроль над запуском тестів

Так само як `cargo run` компілює ваш код і запускає утворений виконуваний файл, `cargo test` компілює ваш код у режимі тестів і запускає утворений тестовий виконуваний файл. За замовчанням виконуваний файл, згенерований `cargo test`, запускає всі тести паралельно і перехоплює вивід, згенерований під час виконання тестів, запобігаючи виведенню на екран і спрощуючи читання виведення, яке стосується результатів тестів. Однак ви можете вказати опції командного рядка, щоб змінити таку поведінку за замовчанням.

Деякі опції командного рядка стосуються `cargo test`, а деякі - вихідного тестового виконуваного файла. Щоб розділити ці два типи аргументів, треба вказати аргументи, що стосуються `cargo test`, далі розділювач `--`, а потім ті, що стосуються тестового виконуваного файлу. Запуск `cargo test --help` покаже опції, що можна використовувати з `cargo test`, а запуск `cargo test -- --help` покаже опції, що можна вказувати після розділювача.

### Запуск тестів паралельно чи послідовно

Коли ви запускаєте декілька тестів, за замовчуванням вони запускаються паралельно у кількох потоках, тобто вони закінчують роботу швидше і ви скоріше отримуєте зворотний зв'язок. Оскільки тести виконуються одночасно, ви повинні переконатися, що ваші тести не залежать один від одного або від будь-якого спільного стану, включно зі спільним середовищем, наприклад поточною робочою текою чи змінною середовища.

Наприклад, нехай кожен з ваших тестів запускає певний код, що створює файл на диску з назвою *test-output.txt* і записує якісь дані в цей файл. Потім кожен тест зчитує дані з цього файлу та перевіряє, що файл містить певне значення, яке різниться в кожному тесті. Оскільки тести виконуються одночасно, один тест може перезаписати файл у час між тим, коли інший тест пише і читає цей файл. Другий тест тоді провалиться - не тому, що код неправильний, але тому, що тести втручалися в роботу один одного під час паралельної роботи. Одне можливе рішення - переконатися, що кожен тест пише в окремий файл; інше рішення - запускати тести по одному за раз.

Якщо ви не хочете запускати тести паралельно, або якщо хочете мати більш докладний контроль над кількістю потоків, ви можете встановити прапорець `--test-threads` і кількість потоків, які Ви хочете використовувати для тестування. Погляньте на наступний приклад:

```console
$ cargo test -- --test-threads=1
```

Ми встановили кількість потоків тестів на значення `1`, які повідомляють програмі не використовувати паралелізм. Виконання тестів за допомогою одного потоку займе більше часу, ніж запуск їх паралельно, але тести не будуть втручатися один одного, якщо вони мають спільний стан.

### Показування виведення функції

За замовчуванням, якщо тест проходить вдало, бібліотека тестування Rust перехоплює все, що виводиться у стандартний вихідний потік. Наприклад, якщо ми викличемо `println!` у тесті й тест проходить, ми не побачимо виведення з `println!` терміналі; ми побачимо тільки рядок, який каже, що тест пройдено. Якщо тест провалено, ми побачимо все, що було виведено до стандартного потоку виведення з рештою повідомлення про помилку.

Як приклад, Блок коду 11-10 має простеньку функцію, яка друкує значення свого параметра і повертає 10, а також і тест, що проходить і тест, що провалюється.

<span class="filename">Файл: src/lib.rs</span>

```rust,panics,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-10/src/lib.rs}}
```


<span class="caption">Блок коду 11-10: Тести для функції, що викликає `println!`</span>

Коли ми запустимо ці тести за допомогою `cargo test`, то побачимо таке:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-10/output.txt}}
```

Зверніть увагу, що у виведеному ніде немає `I got the value 4` - того, що виводиться в тесті, що проходить. Це виведення було перехоплено. Виведення з тесту, що провалився, `I got the value 8`, з'являється в розділі підсумків тесту, де також показана і причина провалу тесту.

Якщо ми хочемо вивести значення і для тестів, що пройшли, ми можемо сказати Rust також показати виведення з успішних тестів за допомогою `--show-output`.

```console
$ cargo test -- --show-output
```

Коли ми запустимо тести з Блоку коду 11-10 знову, вказавши прапорець `--show-output`, то побачимо таке:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-01-show-output/output.txt}}
```

### Запуск підмножини тестів по імені

Іноді виконання повного набору тестів може тривати довго. Якщо ви працюєте над кодом у певній області, то можете захотіти запускати лише тести, що містять цей код. Ви можете обирати, які тести виконати, передавши `cargo test` ім'я чи імена тесту(ів), які хочете запустити, як аргумент.

Щоб продемонструвати, як запустити частину тестів, ми спершу створимо три тести для нашої функції `add_two`, як показано у Блоці коду 11-11, і оберемо, які з них запустити.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-11/src/lib.rs}}
```


<span class="caption">Блок коду 11-11: Три тести з різними іменами</span>

Якщо ми запустимо тести, не передавши жодних аргументів, то, як ми бачили раніше, всі тести запустяться паралельно:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-11/output.txt}}
```

#### Запуск одного тесту

Ми можемо передати назву будь-якої тестової функції `cargo test`, щоб запустити тільки цей тест:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-02-single-test/output.txt}}
```

Лише тест з ім'ям `one_hundred` було виконано; інші два тести мають невідповідні імена. Вивід тесту дає нам знати, що ми мали більше тестів, що не були запущені, показавши наприкінці `2 filtered out`.

Ми не можемо таким чином вказувати імена кількох тестів; буде використане лише перше значення, передане `cargo test`. Але є спосіб запустити кілька тестів.

#### Фільтрування для запуску кількох тестів

Ми можемо вказати частину назви тесту, і всі тести, чиї імена відповідають цьому значенню, будуть запущені. Наприклад, оскільки дві назви наших тестів містять `add`, ми можемо виконати ці два тести, запустивши `cargo test add`:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-03-multiple-tests/output.txt}}
```

Ця команда виконала всі тести, що містили `add` у назві й відфільтрувала тест з назвою `one_hundred`. Також зверніть увагу, що модуль, в якому з'являється тест, перетворюється на частину імені тесту, тож ми можемо запустити усі тести в модулі, відфільтрувавши тести за ім’ям модуля.

### Ігнорування деяких тестів, якщо не було спеціального запиту

Іноді кілька специфічних тестів можуть витрачати дуже багато часу для виконання, так що ви можете захотіти виключити їх під час більшості запусків `cargo test`. Замість того, щоб перелічувати всі тести, які ви хочете запустити, як аргументи, ви можете натомість додати анотацію трудомістких тестів, додавши атрибут `ignore`, щоб виключити їх, як показано тут:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-11-ignore-a-test/src/lib.rs}}
```

Після `#[test]` ми додаємо рядок `#[ignore]` до тесту, що його ми хочемо виключити. Тепер, коли ми запускаємо наші тести, `it_works` запускається, а `expensive_test` - ні:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-11-ignore-a-test/output.txt}}
```

Функція `expensive_test` показана як `ignored`. Якби ми захотіли запустити лише ігноровані тести, то могли б запустити `cargo test -- --ignored`:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-04-running-ignored/output.txt}}
```

Контролюючи, які тести запустити, ви можете забезпечити швидкість результатів `cargo test`. Коли ви дістанетеся до етапу, коли матиме сенс перевірити результати тестів `ignored` і матимете час дочекатися результатів, то зможете натомість запустити `cargo test -- --ignored`. Якщо ви хочете запустити усі тести, ігноровані чи ні, то можете запустити `cargo test -- --include-ignored`.
