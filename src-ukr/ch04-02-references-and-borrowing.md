## Посилання і позичання

Проблема з кодом, що використовує кортежі, з Блоку коду 4-5 полягає в тому, що ми маємо повертати `String` у функцію, що викликає, щоб можна було використовувати `String` після виклику `calculate_length`, бо `String` переміщується до `calculate_length`. Натомість ми можемо надати посилання на значення `String`. *Посилання* - це як вказівник, тобто адреса, за якою можна перейти, щоб отримати дані, збережені за цією адресою; ці дані є володінням якоїсь іншої змінної. На відміну від вказівника, посилання гарантовано вказує на коректне значення певного типу весь час існування цього посилання.

Here is how you would define and use a `calculate_length` function that has a reference to an object as a parameter instead of taking ownership of the value:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:all}}
```

По-перше, зауважте, що весь код із кортежами при визначенні змінної та поверненні з функції зник. По-друге, зауважте, що ми передаємо `&s1` у `calculate_length`, а у визначенні функції ми приймаємо `&String` замість `String`. Ці амперсанди представляють *посилання*, і вони дозволяють нам посилатися на певне значення, не перебираючи володіння ним. Рисунок 4-5 описує цю концепцію.

<img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" />

<span class="caption">Рисунок 4-5: Діаграма, як `&String s` вказує на `String s1`</span>

> Примітка: операція, зворотна до посилання `&`, зветься *розіменуванням*, і виконується оператором розіменування `*`. Ми побачимо деякі застосування оператора розіменування в Розділі 8 і обговоримо подробиці розіменування у Розділі 15.

Розглянемо детальніше виклик функції:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:here}}
```

Запис `&s1` створює посилання, що *посилається* на значення `s1`, але не володіє ним. Оскільки володіння немає, значення, на яке воно вказує, не буде знищене, коли посилання вийде з області видимості.

Так само, сигнатура функції використовує `&`, щоб показати, що тип параметра `s` - посилання. Додамо трохи коментарів для пояснення:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-08-reference-with-annotations/src/main.rs:here}}
```

Область видимості, де змінна `s` є коректною, така сама, як і у будь-якого параметра функції, але значення, на що вказує посилання, не припиняє свого існування коли `s` припиняє використовуватися, бо `s` ним не володіє. Коли функції мають параметри - посилання замість значень, нам не треба повертати значення, щоб повернути володіння, бо ми й не мали володіння.

Операція створення посилання зветься *позичанням*. Як і в справжньому житті, якщо особа володіє чимось, ви можете це позичити у неї , а коли річ вам стане не потрібна, треба її віддати. Бо вона вам не належить.

Що ж станеться, якщо ми спробуємо змінити щось, що ми позичили? Спробуйте запустити код з Блоку коду 4-6. Обережно, спойлер: він не працює!

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-06/src/main.rs}}
```

<span class="caption">Блок коду 4-6: Спроба змінити позичене значення</span>

Ось помилка:

```console
{{#include ../listings/ch04-understanding-ownership/listing-04-06/output.txt}}
```

Посилання, так само як і змінні, за умовчанням є немутабельними. Ми не можемо змінити щось, на що ми маємо посилання.

### Мутабельні посилання

We can fix the code from Listing 4-6 to allow us to modify a borrowed value with just a few small tweaks that use, instead, a *mutable reference*:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-09-fixes-listing-04-06/src/main.rs}}
```

По-перше, треба змінити `s`, щоб він став `mut`. Потім ми створюємо мутабельне посилання за допомогою `&mut
s` там, де викликаємо функцію `change`, і змінюємо сигнатуру функції, щоб вона приймала мутабельне посилання за допомогою `some_string: &mut String`. Це явно показує, що функція `change` змінить позичене значення.

Мутабельні посилання мають одне суттєве обмеження: якщо ви маєте мутабельне посилання на значення, то більше не можете мати інших посилань на це значення. Цей код, що намагається створити два мутабельні посилання на `s`, не спрацює:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/src/main.rs:here}}
```

Ось помилка:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/output.txt}}
```

Помилка каже, що цей код некоректний, бо ми не можемо позичити `s` як мутабельне значення більш ніж один раз. Перше мутабельне позичання знаходиться в `r1` має існувати, доки не буде використане в `println!`, але між створенням цього мутабельного посилання і його використанням, ми намагалися створити ще одне мутабельне посилання в `r2`, що позичає ті ж дані, що й `r1`.

Це обмеження, що забороняє кілька мутабельних посилань на одні й ті самі дані в один час, дозволяє їх змінювати, але під пильним контролем. Це те, із чим борються почтківці-растацеанці, бо більшість мов дозволяють вам змінювати дані коли завгодно. Перевага цього обмеження в тому, що Rust може запобігти гонитві даних під час компіляції. *Гонитва даних* подібна до стану гонитви й стається, коли мають місце такі три умови:

* Два чи більше вказівників мають доступ до одних даних у один і той самий час.
* Щонайменше один зі вказівників використовується для запису даних.
* Не застосовується жодних механізмів синхронізації доступу до даних.

Data races cause undefined behavior and can be difficult to diagnose and fix when you’re trying to track them down at runtime; Rust prevents this problem by refusing to compile code with data races!

As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not *simultaneous* ones:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-11-muts-in-separate-scopes/src/main.rs:here}}
```

Rust застосовує схоже правило для змішування мутабельних і немутабельних посилань. Цей код призводить до помилки:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/src/main.rs:here}}
```

Ось помилка:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/output.txt}}
```

Хух! Не виходить *також* мати мутабельне посилання, коли в нас є немутабельне посилання на це ж значення.

Користувачі немутабельного посилання не очікують, що його значення несподівано зміниться прямо під час використання. Втім, багато немутабельних посилань допустимі, бо жоден з тих, хто просто читає дані, не може вплинути на те, що інші теж читають ці ж дані.

Зверніть увагу, що область видимості посилання починається з місця його проголошення і продовжується до останнього разу, коли посилання використовується. Наприклад, цей код компілюється тому, що останнє використання немутабельних посилань у `println!` відбувається до проголошення мутабельного посилання:

```rust,edition2021
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-13-reference-scope-ends/src/main.rs:here}}
```

Області видимості немутабельних посилань `r1` і `r2` завершуються після `println!`, де вони востаннє використані, тобто перед створенням мутабельного посилання `r3`. Області видимості не накладаються, тому цей код коректний. Здатність компілятора зрозуміти, що посилання більше не використовується в точці до кінця області видимості зветься *нелексичними часами існування* (Non-Lexical Lifetimes, скорочено NLL), і ви можете прочитати більше про них в [Посібнику з редакцій (The Edition Guide)][nll].

Хоча ці помилки часами і дратують, пам'ятайте, що це компілятор Rust вказує на потенційний баг завчасно (під час компіляції замість часу виконання) і точно вказує, де полягає проблема , замість змушувати вас відстежувати, чому іноді ваші дані не такі, як ви очікували.

### Висячі посилання

У мовах із вказівниками легко можна помилково створити *висячий вказівник* - вказівник, що посилається на місце в пам'яті, що було виділене комусь іще - звільнивши пам'ять, але залишивши вказівник на цю пам'ять. У Rust натомість компілятор гарантує, що посилання ніколи не стануть висячими: якщо ви маєте посилання на певні дані, компілятор пересвідчиться, що дані не вийдуть з області видимості раніше за посилання на ці дані.

Let’s try to create a dangling reference to see how Rust prevents them with a compile-time error:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/src/main.rs}}
```

Ось помилка:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/output.txt}}
```

Це повідомлення про помилку посилається на особливість, про яку ми ще не розповідали: час існування. Ми обговоримо часи існування детальніше у Розділі 10. Але, якщо опустити частини про час існування, повідомлення містить ключ до того, чому цей код містить проблему:

```text
this function's return type contains a borrowed value, but there is no value
for it to be borrowed from (тип, що повертає ця функція, містить позичене значення, але немає значення, яке воно може позичити)
```

Подивімося ближче, що саме відбувається на кожному кроці нашого коду `dangle`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-15-dangling-reference-annotated/src/main.rs:here}}
```

Оскільки `s` було створено всередині `dangle`, коли код `dangle` завершується, `s` буде вивільнено. Але ми намагаємося повернути посилання на нього. Це означає, що це посилання буде вказувати на некоректний `String`. Так не можна! І Rust цього не допустить.

Рішення тут - повертати `String` безпосередньо:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-16-no-dangle/src/main.rs:here}}
```

Це працює без проблем. Володіння переміщується з функції, і нічого не звільняється.

### Правила посилань

Ще раз повторимо, що ми обговорили про посилання:

* У будь-який час можна мати *або* одне мутабельне посилання, *або* будь-яку кількість немутабельних посилань.
* Посилання завжди мають бути коректними.

Далі ми поглянемо на інший тип посилань: зрізи.

[nll]: https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html
